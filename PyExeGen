import json
import os
import shlex
import subprocess
import sys
import threading
import time
import tkinter as tk
from dataclasses import dataclass, field
from datetime import datetime
from tkinter import filedialog, messagebox, scrolledtext, ttk
from typing import List, Optional, Tuple

CONFIG_PATH = os.path.join(os.path.expanduser("~"), ".pyinstaller_gui.json")


@dataclass
class BuildOptions:
    py_file: str = ""
    name: str = ""
    onefile: bool = True
    windowed: bool = True  # False -> console
    icon: str = ""
    hidden_imports: List[str] = field(default_factory=list)
    add_data: List[Tuple[str, str]] = field(default_factory=list)  # (src, dest)
    clean: bool = True
    noconfirm: bool = True
    distpath: str = ""
    workpath: str = ""
    specpath: str = ""
    arch: str = "auto"  # auto | x86 | x64 (Windows only)


class PyInstallerGUI:
    """
    Улучшенный GUI для сборки EXE/PyInstaller.
    - Потокобезопасный лог
    - Отмена сборки
    - Выбор разрядности (Windows: auto/x86/x64)
    - Полезные опции PyInstaller
    - Правая панель редактора кода, автосохранение и запуск
    """

    def __init__(self, root: tk.Tk) -> None:
        self.root = root
        self.root.title("PyInstaller GUI")
        self.root.geometry("1280x800")
        self.is_windows = (os.name == "nt")
        self.process: Optional[subprocess.Popen] = None
        self.build_thread: Optional[threading.Thread] = None

        self.opts = BuildOptions()
        self._load_config()

        # флаги/состояния редактора
        self.code_dirty: bool = False
        self.current_file_path: Optional[str] = None
        self.name_autofill: bool = True  # пока пользователь не правил поле имени

        self._build_ui()
        self._populate_from_options()

    # -------------------------- UI --------------------------

    def _build_ui(self) -> None:
        # 2 колонки: слева — настройки, справа — редактор
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_columnconfigure(1, weight=1)

        # ======= СЛЕВА: ПАНЕЛИ НАСТРОЕК (как в исходном коде) =======

        # Файл
        file_frame = ttk.LabelFrame(self.root, text="Исходный .py файл")
        file_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        file_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(file_frame, text="Файл:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.file_entry = ttk.Entry(file_frame)
        self.file_entry.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(file_frame, text="Обзор…", command=self.browse_file).grid(row=0, column=2, padx=5, pady=5)

        ttk.Label(file_frame, text="Имя (-n/--name):").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.name_entry = ttk.Entry(file_frame)
        self.name_entry.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
        self.name_entry.bind("<Key>", lambda e: setattr(self, "name_autofill", False))

        # Архитектура
        arch_frame = ttk.LabelFrame(self.root, text="Архитектура (Windows)")
        arch_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        self.arch_var = tk.StringVar(value="auto")
        ttk.Radiobutton(arch_frame, text="Auto (как интерпретатор)", variable=self.arch_var, value="auto").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        rb_x86 = ttk.Radiobutton(arch_frame, text="x86 (32-bit)", variable=self.arch_var, value="x86")
        rb_x64 = ttk.Radiobutton(arch_frame, text="x64 (64-bit)", variable=self.arch_var, value="x64")
        rb_x86.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        rb_x64.grid(row=0, column=2, padx=5, pady=5, sticky="w")
        if not self.is_windows:
            for child in arch_frame.winfo_children():
                child.configure(state="disabled")

        # Режимы
        mode_frame = ttk.LabelFrame(self.root, text="Режимы сборки")
        mode_frame.grid(row=2, column=0, padx=10, pady=5, sticky="ew")

        self.onefile_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(mode_frame, text="--onefile (один exe)", variable=self.onefile_var).grid(row=0, column=0, padx=5, pady=5, sticky="w")

        self.gui_mode_var = tk.StringVar(value="windowed")
        ttk.Radiobutton(mode_frame, text="--windowed (без консоли)", variable=self.gui_mode_var, value="windowed").grid(row=0, column=1, padx=5, pady=5, sticky="w")
        ttk.Radiobutton(mode_frame, text="console (c консолью)", variable=self.gui_mode_var, value="console").grid(row=0, column=2, padx=5, pady=5, sticky="w")

        self.clean_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(mode_frame, text="--clean", variable=self.clean_var).grid(row=1, column=0, padx=5, pady=5, sticky="w")

        self.noconfirm_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(mode_frame, text="--noconfirm", variable=self.noconfirm_var).grid(row=1, column=1, padx=5, pady=5, sticky="w")

        # Иконка
        icon_frame = ttk.LabelFrame(self.root, text="Иконка и пути")
        icon_frame.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        icon_frame.grid_columnconfigure(1, weight=1)
        for r in range(3):
            icon_frame.grid_rowconfigure(r, weight=0)

        ttk.Label(icon_frame, text="Иконка (.ico):").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.icon_entry = ttk.Entry(icon_frame)
        self.icon_entry.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(icon_frame, text="Обзор…", command=self.browse_icon).grid(row=0, column=2, padx=5, pady=5)

        ttk.Label(icon_frame, text="distpath:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.dist_entry = ttk.Entry(icon_frame)
        self.dist_entry.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(icon_frame, text="Папка…", command=lambda: self._choose_dir(self.dist_entry)).grid(row=1, column=2, padx=5, pady=5)

        ttk.Label(icon_frame, text="workpath (build):").grid(row=2, column=0, padx=5, pady=5, sticky="w")
        self.work_entry = ttk.Entry(icon_frame)
        self.work_entry.grid(row=2, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(icon_frame, text="Папка…", command=lambda: self._choose_dir(self.work_entry)).grid(row=2, column=2, padx=5, pady=5)

        ttk.Label(icon_frame, text="specpath:").grid(row=3, column=0, padx=5, pady=5, sticky="w")
        self.spec_entry = ttk.Entry(icon_frame)
        self.spec_entry.grid(row=3, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(icon_frame, text="Папка…", command=lambda: self._choose_dir(self.spec_entry)).grid(row=3, column=2, padx=5, pady=5)

        # Скрытые импорты / данные
        adv_frame = ttk.LabelFrame(self.root, text="Скрытые импорты и ресурсы")
        adv_frame.grid(row=4, column=0, padx=10, pady=5, sticky="nsew")
        self.root.grid_rowconfigure(4, weight=1)
        adv_frame.grid_columnconfigure(0, weight=1)
        adv_frame.grid_columnconfigure(1, weight=1)

        # hidden imports
        hidden_frame = ttk.Frame(adv_frame)
        hidden_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        adv_frame.grid_rowconfigure(0, weight=1)
        ttk.Label(hidden_frame, text="Скрытые импорты (по одному в строке):").pack(anchor="w")
        self.hidden_text = scrolledtext.ScrolledText(hidden_frame, height=8)
        self.hidden_text.pack(fill="both", expand=True, pady=(5, 0))

        # add-data
        data_frame = ttk.Frame(adv_frame)
        data_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        ttk.Label(data_frame, text="Ресурсы (--add-data src;dest):").grid(row=0, column=0, sticky="w", padx=0, pady=(0, 5))
        btns = ttk.Frame(data_frame)
        btns.grid(row=0, column=1, sticky="e")
        ttk.Button(btns, text="Добавить файл…", command=self.add_data_file).grid(row=0, column=0, padx=3)
        ttk.Button(btns, text="Добавить папку…", command=self.add_data_dir).grid(row=0, column=1, padx=3)
        ttk.Button(btns, text="Удалить выбранное", command=self.remove_selected_data).grid(row=0, column=2, padx=3)

        self.data_tree = ttk.Treeview(data_frame, columns=("src", "dest"), show="headings", height=7)
        self.data_tree.heading("src", text="Источник")
        self.data_tree.heading("dest", text="Назначение (относит.)")
        self.data_tree.column("src", width=320)
        self.data_tree.column("dest", width=160)
        self.data_tree.grid(row=1, column=0, columnspan=2, sticky="nsew")
        data_frame.grid_rowconfigure(1, weight=1)
        data_frame.grid_columnconfigure(0, weight=1)

        # Кнопки управления
        ctrl = ttk.Frame(self.root)
        ctrl.grid(row=5, column=0, padx=10, pady=10, sticky="ew")
        ttk.Button(ctrl, text="Собрать EXE", command=self.build_exe).pack(side="left")
        ttk.Button(ctrl, text="Запустить", command=self.run_app).pack(side="left", padx=5)
        self.cancel_btn = ttk.Button(ctrl, text="Отменить", command=self.cancel_build, state="disabled")
        self.cancel_btn.pack(side="left", padx=5)
        ttk.Button(ctrl, text="Открыть dist", command=self.open_dist).pack(side="left", padx=5)
        ttk.Button(ctrl, text="Очистить лог", command=self.clear_log).pack(side="left", padx=5)
        ttk.Button(ctrl, text="Сохранить настройки", command=self._save_config_from_ui).pack(side="left", padx=5)

        # Прогресс
        self.progress = ttk.Progressbar(self.root, orient="horizontal", mode="indeterminate", length=400)
        self.progress.grid(row=6, column=0, padx=10, pady=(0, 10), sticky="ew")

        # Лог
        log_frame = ttk.LabelFrame(self.root, text="Лог сборки")
        log_frame.grid(row=7, column=0, padx=10, pady=(0, 10), sticky="nsew")
        self.root.grid_rowconfigure(7, weight=1)
        self.log_text = scrolledtext.ScrolledText(log_frame, width=100, height=18, state=tk.DISABLED)
        self.log_text.pack(fill="both", expand=True, padx=5, pady=5)

        # ======= СПРАВА: РЕДАКТОР КОДА =======

        editor_frame = ttk.LabelFrame(self.root, text="Редактор кода")
        editor_frame.grid(row=0, column=1, rowspan=8, padx=(0, 10), pady=10, sticky="nsew")
        # чтобы тянулся
        editor_frame.grid_columnconfigure(0, weight=1)
        editor_frame.grid_rowconfigure(1, weight=1)

        editor_top = ttk.Frame(editor_frame)
        editor_top.grid(row=0, column=0, sticky="ew", padx=6, pady=(6, 0))
        editor_top.grid_columnconfigure(0, weight=1)

        self.editor_path_var = tk.StringVar(value="(файл не выбран)")
        ttk.Label(editor_top, textvariable=self.editor_path_var).grid(row=0, column=0, sticky="w")

        # Кнопки редактора
        ebtns = ttk.Frame(editor_frame)
        ebtns.grid(row=0, column=0, sticky="e", padx=6, pady=(6, 0))
        ttk.Button(ebtns, text="Открыть…", command=self.browse_file).pack(side="left", padx=3)
        ttk.Button(ebtns, text="Сохранить", command=self.save_editor).pack(side="left", padx=3)
        ttk.Button(ebtns, text="Сохранить как…", command=self.save_editor_as).pack(side="left", padx=3)

        # Поле текста
        self.editor_text = scrolledtext.ScrolledText(editor_frame, wrap="none", undo=True)
        self.editor_text.grid(row=1, column=0, sticky="nsew", padx=6, pady=6)
        # события редактора
        self.editor_text.bind("<<Modified>>", self._on_editor_modified)
        self._init_editor_context_menu()

    # -------------------------- Helpers --------------------------

    def _init_editor_context_menu(self) -> None:
        menu = tk.Menu(self.root, tearoff=0)
        menu.add_command(label="Вырезать", command=lambda: self.editor_text.event_generate("<<Cut>>"))
        menu.add_command(label="Копировать", command=lambda: self.editor_text.event_generate("<<Copy>>"))
        menu.add_command(label="Вставить", command=lambda: self.editor_text.event_generate("<<Paste>>"))
        menu.add_separator()
        menu.add_command(label="Выделить всё", command=lambda: (self.editor_text.tag_add("sel", "1.0", "end-1c"), self.editor_text.focus()))
        self.editor_menu = menu

        def popup(event):
            try:
                self.editor_menu.tk_popup(event.x_root, event.y_root)
            finally:
                self.editor_menu.grab_release()

        self.editor_text.bind("<Button-3>", popup)
        # на Mac иногда правая кнопка — Button-2
        self.editor_text.bind("<Button-2>", popup)

    def _on_editor_modified(self, _event=None) -> None:
        # Сбрасываем флаг "Modified", сохраняем свой
        self.editor_text.edit_modified(False)
        self.code_dirty = True

    def browse_file(self) -> None:
        path = filedialog.askopenfilename(title="Выберите .py файл", filetypes=[("Python Files", "*.py")])
        if path:
            self.file_entry.delete(0, tk.END)
            self.file_entry.insert(0, path)
            self._update_name_from_path(path)
            self._load_code(path)

    def _update_name_from_path(self, path: str) -> None:
        base = os.path.splitext(os.path.basename(path))[0]
        # автоподстановка, пока пользователь сам не правил имя
        if self.name_autofill or not self.name_entry.get().strip():
            self.name_entry.delete(0, tk.END)
            self.name_entry.insert(0, base)

    def _load_code(self, path: str) -> None:
        try:
            with open(path, "r", encoding="utf-8") as f:
                code = f.read()
        except UnicodeDecodeError:
            # попытка cp1251 и пр.
            with open(path, "r", encoding="cp1251") as f:
                code = f.read()
        self.editor_text.delete("1.0", tk.END)
        self.editor_text.insert("1.0", code)
        self.code_dirty = False
        self.current_file_path = path
        self.editor_path_var.set(path)

    def save_editor(self) -> Optional[str]:
        """Сохраняет содержимое редактора в текущий файл или спрашивает 'Сохранить как'."""
        path = self.current_file_path or self.file_entry.get().strip()
        if not path:
            return self.save_editor_as()
        return self._save_code_to(path)

    def save_editor_as(self) -> Optional[str]:
        path = filedialog.asksaveasfilename(
            title="Сохранить как",
            defaultextension=".py",
            filetypes=[("Python Files", "*.py")],
            initialfile=self._default_program_name() + ".py"
        )
        if not path:
            return None
        return self._save_code_to(path)

    def _save_code_to(self, path: str) -> Optional[str]:
        code = self.editor_text.get("1.0", "end-1c")
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(code)
        except Exception as e:
            self._show_error(f"Не удалось сохранить файл:\n{e}")
            return None
        self._append_log(f"[Файл] Сохранено: {path}\n")
        self.code_dirty = False
        self.current_file_path = path
        self.editor_path_var.set(path)
        # синхронизируем поле и имя, если надо
        self.file_entry.delete(0, tk.END)
        self.file_entry.insert(0, path)
        self._update_name_from_path(path)
        return path

    def _default_program_name(self) -> str:
        # исправляем опечатку из ТЗ: используем 'py_program'
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"py_program_{ts}"

    def browse_icon(self) -> None:
        path = filedialog.askopenfilename(title="Выберите .ico файл", filetypes=[("Icon", "*.ico"), ("Все файлы", "*.*")])
        if path:
            self.icon_entry.delete(0, tk.END)
            self.icon_entry.insert(0, path)

    def _choose_dir(self, entry: ttk.Entry) -> None:
        path = filedialog.askdirectory()
        if path:
            entry.delete(0, tk.END)
            entry.insert(0, path)

    def add_data_file(self) -> None:
        path = filedialog.askopenfilename(title="Добавить файл ресурса")
        if path:
            dest = self._ask_dest(os.path.basename(path))
            if dest is not None:
                self.data_tree.insert("", "end", values=(path, dest))

    def add_data_dir(self) -> None:
        path = filedialog.askdirectory(title="Добавить папку ресурса")
        if path:
            dest = self._ask_dest(os.path.basename(path))
            if dest is not None:
                self.data_tree.insert("", "end", values=(path, dest))

    def _ask_dest(self, suggested: str) -> Optional[str]:
        win = tk.Toplevel(self.root)
        win.title("Назначение ресурса")
        win.transient(self.root)
        win.grab_set()
        ttk.Label(win, text="Путь назначения внутри пакета:").grid(row=0, column=0, padx=10, pady=10, sticky="w")
        e = ttk.Entry(win, width=40)
        e.grid(row=1, column=0, padx=10, pady=(0, 10))
        e.insert(0, suggested)
        res = {"val": None}

        def ok():
            res["val"] = e.get().strip()
            win.destroy()

        def cancel():
            res["val"] = None
            win.destroy()

        btns = ttk.Frame(win)
        btns.grid(row=2, column=0, padx=10, pady=10, sticky="e")
        ttk.Button(btns, text="OK", command=ok).pack(side="left", padx=5)
        ttk.Button(btns, text="Отмена", command=cancel).pack(side="left")
        self.root.wait_window(win)
        return res["val"]

    def remove_selected_data(self) -> None:
        for item in self.data_tree.selection():
            self.data_tree.delete(item)

    def clear_log(self) -> None:
        self._set_log_state(tk.NORMAL)
        self.log_text.delete("1.0", tk.END)
        self._set_log_state(tk.DISABLED)

    def open_dist(self) -> None:
        dist = self.dist_entry.get().strip() or os.path.abspath("dist")
        if not os.path.exists(dist):
            self._show_error(f"Папка не найдена: {dist}")
            return
        try:
            if self.is_windows:
                os.startfile(dist)  # type: ignore[attr-defined]
            elif sys.platform == "darwin":
                subprocess.Popen(["open", dist])
            else:
                subprocess.Popen(["xdg-open", dist])
        except Exception as e:
            self._show_error(str(e))

    # -------------------------- Build / Run Flow --------------------------

    def build_exe(self) -> None:
        # Сбор опций из UI
        self._opts_from_ui()

        # Обеспечиваем наличие исходника: сохраняем изменения, создаём файл при необходимости
        ensured = self._ensure_source_file()
        if not ensured:
            return  # ошибка уже показана

        # Повторно читаем опции, т.к. могли обновить путь и имя
        self._opts_from_ui()

        # Валидация
        if not self.opts.py_file:
            self._show_error("Сначала выберите .py файл или введите код в редакторе.")
            return
        if not os.path.exists(self.opts.py_file):
            self._show_error(f"Файл не найден: {self.opts.py_file}")
            return
        if self.opts.icon and not os.path.exists(self.opts.icon):
            self._show_error(f"Иконка не найдена: {self.opts.icon}")
            return
        for src, _ in self.opts.add_data:
            if not os.path.exists(src):
                self._show_error(f"Ресурс не найден: {src}")
                return

        # Конструируем команду
        try:
            command = self._construct_command()
        except FileNotFoundError as e:
            self._show_error(str(e))
            return

        self.clear_log()
        self._append_log("Запуск сборки:\n  " + self._format_cmd_for_log(command) + "\n\n")
        self._lock_controls(True)
        self.progress.start(10)
        self.cancel_btn.configure(state="normal")

        # Запуск в потоке
        self.build_thread = threading.Thread(target=self._run_build, args=(command,), daemon=True)
        self.build_thread.start()

    def run_app(self) -> None:
        """Запускает готовый exe/бинарник, иначе — .py выбранным интерпретатором."""
        self._opts_from_ui()
        ensured = self._ensure_source_file()
        if not ensured:
            return
        self._opts_from_ui()

        name = self.opts.name.strip() or os.path.splitext(os.path.basename(self.opts.py_file))[0]
        dist = self.dist_entry.get().strip() or os.path.abspath("dist")

        # предполагаемые пути бинарника
        if self.opts.onefile:
            exe_path = os.path.join(dist, f"{name}.exe") if self.is_windows else os.path.join(dist, name)
        else:
            exe_path = os.path.join(dist, name, f"{name}.exe") if self.is_windows else os.path.join(dist, name, name)

        if os.path.exists(exe_path):
            self._append_log(f"[Запуск] {exe_path}\n")
            try:
                if self.is_windows:
                    subprocess.Popen([exe_path], cwd=os.path.dirname(exe_path))
                else:
                    subprocess.Popen([exe_path], cwd=os.path.dirname(exe_path))
            except Exception as e:
                self._show_error(f"Не удалось запустить бинарник:\n{e}")
            return

        # иначе — запускаем .py
        try:
            runner = self._get_runner(self.opts.arch)
        except FileNotFoundError as e:
            self._show_error(str(e))
            return
        cmd = runner + [self.opts.py_file]
        self._append_log(f"[Запуск .py] {' '.join(cmd)}\n")
        try:
            subprocess.Popen(cmd, cwd=os.path.dirname(self.opts.py_file) or None)
        except Exception as e:
            self._show_error(f"Не удалось запустить .py:\n{e}")

    def cancel_build(self) -> None:
        proc = self.process
        if proc and proc.poll() is None:
            try:
                self._append_log("\nПрерывание сборки…\n")
                proc.terminate()
                try:
                    proc.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    proc.kill()
            except Exception as e:
                self._show_error(f"Не удалось остановить процесс: {e}")

    # -------------------------- Command construction --------------------------

    def _get_runner(self, arch: str) -> List[str]:
        """Возвращает команду запуска интерпретатора с учётом архитектуры на Windows."""
        if self.is_windows and arch in ("x86", "x64"):
            key = "-3-32" if arch == "x86" else "-3-64"
            runner = ["py", key]
            try:
                test = subprocess.run(runner + ["-V"], capture_output=True, text=True)
                if test.returncode != 0:
                    raise FileNotFoundError
            except FileNotFoundError:
                raise FileNotFoundError("Не найден 'py' launcher/интерпретатор нужной разрядности. Установите его или выберите 'Auto'.")
            return runner
        return [sys.executable]

    def _construct_command(self) -> List[str]:
        runner = self._get_runner(self.opts.arch)

        cmd: List[str] = runner + ["-m", "PyInstaller"]

        if self.opts.onefile:
            cmd.append("--onefile")
        # console/windowed
        if self.opts.windowed:
            cmd.append("--windowed")

        if self.opts.name:
            cmd += ["--name", self.opts.name]
        if self.opts.icon:
            cmd += ["--icon", self.opts.icon]
        if self.opts.clean:
            cmd.append("--clean")
        if self.opts.noconfirm:
            cmd.append("--noconfirm")
        if self.opts.distpath:
            cmd += ["--distpath", self.opts.distpath]
        if self.opts.workpath:
            cmd += ["--workpath", self.opts.workpath]
        if self.opts.specpath:
            cmd += ["--specpath", self.opts.specpath]

        for hi in self.opts.hidden_imports:
            if hi:
                cmd += ["--hidden-import", hi]

        # add-data
        sep = ";" if self.is_windows else ":"
        for src, dest in self.opts.add_data:
            cmd += ["--add-data", f"{src}{sep}{dest}"]

        cmd.append(self.opts.py_file)
        return cmd

    def _run_build(self, command: List[str]) -> None:
        try:
            self.process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True
            )
        except Exception as e:
            self.root.after(0, self._on_build_finished, 1, f"Ошибка запуска PyInstaller: {e}")
            return

        exit_code = None
        try:
            assert self.process.stdout is not None
            for line in self.process.stdout:
                self._append_log(line)
            exit_code = self.process.wait()
        except Exception as e:
            self._append_log(f"\nОшибка выполнения: {e}\n")
        finally:
            self.root.after(0, self._on_build_finished, exit_code, None)

    def _on_build_finished(self, exit_code: Optional[int], err: Optional[str]) -> None:
        self.progress.stop()
        self.cancel_btn.configure(state="disabled")
        self._lock_controls(False)
        self.process = None
        if err:
            self._show_error(err)
            return

        if exit_code == 0:
            self._append_log("\n✅ Сборка завершена успешно.\n")
            # Пытаемся вывести путь до результата
            dist = self.dist_entry.get().strip() or os.path.abspath("dist")
            self._append_log(f"Готовые файлы лежат в: {dist}\n")
        else:
            self._append_log(f"\n❌ Сборка завершилась с кодом {exit_code}.\n")
            self._show_error("Сборка не удалась. Проверьте лог выше.")

        # Автосохранение конфигурации
        self._save_config_from_ui(silent=True)

    # -------------------------- Source / Options utils --------------------------

    def _ensure_source_file(self) -> bool:
        """
        Гарантирует наличие .py для сборки/запуска:
        - если выбран файл и редактор изменён — автосохранить в этот файл;
        - если файл не выбран, но код есть — создать файл (и проставить имя при необходимости).
        """
        code = self.editor_text.get("1.0", "end-1c").rstrip()
        path = self.file_entry.get().strip()

        # Если файл выбран и есть несохранённые изменения — сохраняем
        if path and self.code_dirty:
            saved = self._save_code_to(path)
            return saved is not None

        # Если файл не выбран, но код есть — создаём новый .py
        if not path and code:
            name = self.name_entry.get().strip() or self._default_program_name()
            # синхронизируем имя (если было пустым)
            if not self.name_entry.get().strip():
                self.name_entry.insert(0, name)

            filename = f"{name}.py"
            # избегаем перезаписи
            i = 1
            out_path = os.path.abspath(filename)
            while os.path.exists(out_path):
                out_path = os.path.abspath(f"{name}_{i}.py")
                i += 1
            try:
                with open(out_path, "w", encoding="utf-8") as f:
                    f.write(code + "\n")
            except Exception as e:
                self._show_error(f"Не удалось создать файл исходника:\n{e}")
                return False
            self._append_log(f"[Файл] Создан новый исходник: {out_path}\n")
            self.file_entry.delete(0, tk.END)
            self.file_entry.insert(0, out_path)
            self.current_file_path = out_path
            self.editor_path_var.set(out_path)
            self.code_dirty = False
            # включаем автоподстановку для согласованности
            if self.name_autofill or not self.name_entry.get().strip():
                self._update_name_from_path(out_path)

        return True

    def _append_log(self, message: str) -> None:
        self.root.after(0, self._update_log, message)

    def _update_log(self, message: str) -> None:
        self._set_log_state(tk.NORMAL)
        self.log_text.insert(tk.END, message)
        self.log_text.see(tk.END)
        self._set_log_state(tk.DISABLED)

    def _set_log_state(self, state: str) -> None:
        self.log_text.configure(state=state)

    def _show_error(self, msg: str) -> None:
        self._append_log(f"\n[Ошибка] {msg}\n")
        self.root.after(0, lambda: messagebox.showerror("Ошибка", msg))

    def _lock_controls(self, lock: bool) -> None:
        state = "disabled" if lock else "normal"
        for w in (
            self.file_entry, self.name_entry, self.icon_entry,
            self.hidden_text, self.dist_entry, self.work_entry, self.spec_entry,
            self.editor_text
        ):
            try:
                w.configure(state=state)
            except Exception:
                pass
        for tree in (self.data_tree,):
            tree.configure(selectmode=("none" if lock else "extended"))
        # Кнопки
        for frame in self.root.winfo_children():
            if isinstance(frame, (ttk.Labelframe, ttk.Frame)):
                for child in frame.winfo_children():
                    if isinstance(child, ttk.Button):
                        if child is self.cancel_btn:
                            continue
                        try:
                            child.configure(state=state)
                        except Exception:
                            pass
        if lock:
            self.cancel_btn.configure(state="normal")

    def _format_cmd_for_log(self, cmd: List[str]) -> str:
        # Красиво экранируем для копирования в терминал
        if self.is_windows:
            return " ".join([self._quote_win(a) for a in cmd])
        else:
            return " ".join(shlex.quote(a) for a in cmd)

    @staticmethod
    def _quote_win(s: str) -> str:
        # Простое экранирование для Windows-cmd
        if " " in s or any(c in s for c in '^&|<>"'):
            return f'"{s}"'
        return s

    # -------------------------- Options <-> UI --------------------------

    def _opts_from_ui(self) -> None:
        self.opts.py_file = self.file_entry.get().strip()
        self.opts.name = self.name_entry.get().strip()
        self.opts.onefile = self.onefile_var.get()
        self.opts.windowed = (self.gui_mode_var.get() == "windowed")
        self.opts.icon = self.icon_entry.get().strip()
        self.opts.clean = self.clean_var.get()
        self.opts.noconfirm = self.noconfirm_var.get()
        self.opts.distpath = self.dist_entry.get().strip()
        self.opts.workpath = self.work_entry.get().strip()
        self.opts.specpath = self.spec_entry.get().strip()
        self.opts.arch = self.arch_var.get()

        # hidden imports
        text = self.hidden_text.get("1.0", tk.END).strip()
        self.opts.hidden_imports = [line.strip() for line in text.splitlines() if line.strip()]

        # add-data
        self.opts.add_data = []
        for iid in self.data_tree.get_children(""):
            src, dest = self.data_tree.item(iid, "values")
            self.opts.add_data.append((src, dest))

    def _populate_from_options(self) -> None:
        self.file_entry.delete(0, tk.END)
        self.file_entry.insert(0, self.opts.py_file)

        self.name_entry.delete(0, tk.END)
        self.name_entry.insert(0, self.opts.name)

        self.onefile_var.set(self.opts.onefile)
        self.gui_mode_var.set("windowed" if self.opts.windowed else "console")

        self.icon_entry.delete(0, tk.END)
        self.icon_entry.insert(0, self.opts.icon)

        self.clean_var.set(self.opts.clean)
        self.noconfirm_var.set(self.opts.noconfirm)

        self.dist_entry.delete(0, tk.END)
        self.dist_entry.insert(0, self.opts.distpath)
        self.work_entry.delete(0, tk.END)
        self.work_entry.insert(0, self.opts.workpath)
        self.spec_entry.delete(0, tk.END)
        self.spec_entry.insert(0, self.opts.specpath)

        self.arch_var.set(self.opts.arch)

        self.hidden_text.delete("1.0", tk.END)
        if self.opts.hidden_imports:
            self.hidden_text.insert("1.0", "\n".join(self.opts.hidden_imports))

        for item in self.data_tree.get_children(""):
            self.data_tree.delete(item)
        for src, dest in self.opts.add_data:
            self.data_tree.insert("", "end", values=(src, dest))

        # если путь задан — подгрузим код
        if self.opts.py_file and os.path.exists(self.opts.py_file):
            try:
                self._load_code(self.opts.py_file)
            except Exception:
                pass

    # -------------------------- Config persistence --------------------------

    def _load_config(self) -> None:
        try:
            if os.path.exists(CONFIG_PATH):
                with open(CONFIG_PATH, "r", encoding="utf-8") as f:
                    data = json.load(f)
                self.opts = BuildOptions(
                    py_file=data.get("py_file", ""),
                    name=data.get("name", ""),
                    onefile=data.get("onefile", True),
                    windowed=data.get("windowed", True),
                    icon=data.get("icon", ""),
                    hidden_imports=data.get("hidden_imports", []),
                    add_data=data.get("add_data", []),
                    clean=data.get("clean", True),
                    noconfirm=data.get("noconfirm", True),
                    distpath=data.get("distpath", ""),
                    workpath=data.get("workpath", ""),
                    specpath=data.get("specpath", ""),
                    arch=data.get("arch", "auto"),
                )
        except Exception:
            # тихо игнорируем битую конфигурацию
            pass

    def _save_config_from_ui(self, silent: bool = False) -> None:
        self._opts_from_ui()
        try:
            with open(CONFIG_PATH, "w", encoding="utf-8") as f:
                json.dump(self.opts.__dict__, f, ensure_ascii=False, indent=2)
            if not silent:
                messagebox.showinfo("Сохранено", f"Настройки записаны в {CONFIG_PATH}")
        except Exception as e:
            if not silent:
                self._show_error(f"Не удалось сохранить настройки: {e}")


def main() -> None:
    root = tk.Tk()
    # Небольшая полировка UI
    try:
        root.iconbitmap(default="")  # не падаем, если нет иконки
    except Exception:
        pass
    style = ttk.Style(root)
    # На Windows часто доступна "vista", на *nix — "clam"
    for theme in ("vista", "xpnative", "clam", "default"):
        if theme in style.theme_names():
            style.theme_use(theme)
            break
    app = PyInstallerGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()

